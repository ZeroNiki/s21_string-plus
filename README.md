# String+
## Make
```sh
make
```
- Создаёт статическию либу `s21_string.a`
```sh
make test
```
- Прогонит тесты

```sh
make review
```
- Создаст рапорт который находиться в `gcov-rep/report.html`

```sh
make format-check
```
- Проверка на `clang`

```sh
make cppcheck
```
- Проверка на `cppcheck`

```sh
make memcheck
```
- Проверка на утечку

## TODO
✅- Clang-format
✅- Cppcheck


| Функция          | Выполнено ✅ |
|-----------------|-------------|
| **Part 1**       |             |
| `strchr (6)`     | ✅           |
| `strpbrk (12)`   | ✅           |
| `strrchr (13)`   | ✅           |
| `strstr (14)`    | ✅           |
| `strtok (15)`    | ✅           |
| **Tests for all** | ✅           |
| **Build Automation** | ✅       |
| **Sprintf**      | ✅           |
|------------------|--------------|
* | **Part 1**       |             |
| `memchr (1)`     | ✅           |
| `memcmp (2)`     | ✅           |
| `memcpy (3)`     | ✅           |
| `memset (4)`     | ✅           |
| **Part 5**       |             |
| `to_lower`       | ✅           |
| `to_upper`       | ✅           |
| `insert`         | ✅           |
| `trim`           | ✅           |
|------------------|--------------|
| **Part 1**       |             |
| `strncat (5)`    | ✅           |
| `strncmp (7)`    | ✅           |
| `strncpy (8)`    | ✅           |
| `strcspn (9)`    | ✅           |
| `strerror (10)`  | ✅           |
| `strlen (11)`    | ✅           |

## DOC
### Part 1.
#### 0.0 s21_size_t
```c
typedef long unsigned s21_size_t;
```
`size_t` - это просто безнаковое длинное число. Мы его определяем его через `typedef`

#### 0.1 s21_NULL
```c
#define s21_NULL ((void *)0)
```
Макрос который определяет `s21_NULL` как `(void *)0`. `(void *)0` - это тот же самый `NULL`. Используется, чтобы обозначать "отсутствие указателя" в коде

#### 1 s21_memchr
`memchr` - ищёт первое вхождение символа `c` в первых `n` байтах

```c
for (s21_size_t i = 0; i < n; i++) {
    if (s[i] == ch) {
      return (void *)(s + i);
    }
}
```
- Проходим по `n` символам
- Если найден `ch` (`unsigned char`), то возращяем указатель на этот байт
- В ином случае `s21_NULL`

#### 2 s21_memcmp
`memcmp` - сравнение первых `n` байтов двух блоков `str1` и `str2`

```c
  for (s21_size_t i = 0; i < n; i++) {
    if (s1[i] != s2[i]) {
      return s1[i] - s2[i];
    }
  }
```
- Проходимся по `n` байтам
- Если есть различия возращям разницу между блоками памяти
- Если они равны то идём дальше
- Если `str1 == str2` то `0`

#### 3 s21_memcpy
`memcpy` - копирует `n` байтов из `src` в `dest`

```c
while (n--) {
  *d++ = *s++;
}
```
- Пока `n != 0` копируем байты по одному
- `*d++ = *s++` копирует один байт и сдвигает указатели
- `n--` уменьшаем счётчик байтов
- Возращяем указатель на `dest`

#### 4 s21_memset
`memset`- заполняет первые `n` байтов области памяти `str` значениями `c`

```c
while (n--) {
  *s++ = (unsigned char)c;
}
```
- Пока `n > 0` записываем в `*s` значения `(unsigned char)c` и двигаем указатель
- `n--` уменьшаем счётчик байтов
- Возращяем указатель на изм. `src`

-----------
#### 5 s21_strncat
`strcat`- объединяет две строки, добовляя `src` в конец `dest`

```c
while (*ptr != '\0') {
  ptr++;
}
```
- Ищем конец `dest`

```c
while (*src != '\0') {
  *ptr = *src;
  ptr++;
  src++;
}
```
- Копируем символы

#### 6 s21_strchr
`strchr` - поиск первого вхождения `c`

```c
while (*str != '\0') {
  if (*str == c) {
    return (char *)str;
  }

  str++;
}
```
- Двигаем `*str` да `\0`
- Если мы находим `c` в `str` возращяем его
- в ином случаее идём дальше или возр. `s21_NULL`
- 

#### 7 s21_strncmp
`strcmp` - тоже самое что и `memcmp` только работа идёт не с байтами а со строками

```c
while (*str1 != '\0' && *str1 == *str2) {
    str1++;
    str2++;
}

return (char)*str1 - (char)*str2;
```

- Идём пока `str1` не равен концу строки И пока они не будут равны
- Если есть различия выходим из цикла и возращяем разницу
- Если они равны то результатом вычитания будет `0`

#### 8 s21_strncpy
`strncpy` - копирования `n` символов из `src` в `dest` (Тоже самое что и `memcpy`)

```c
s21_size_t i;

for (i = 0; i < n && src[i] != '\0'; i++) {
  dest[i] = src[i];
}
```
- Проходим до `n` или до конца
- Копируем символы

```c
while (i < n) {
  dest[i++] = '\0';
}
```
- Если `src` короче `n`, то оставшиеся символы будут заполнятся `\0`

#### 9 s21_strcspn
`strcspn` - вычисляет длину начального сегмента `str1` который не содержит символы из `str2`

```c
while (str1[k] != '\0') {
  for (s21_size_t i = 0; str2[i] != '\0'; i++) {
    if (str1[k] == str2[i]) {
      return k;
    }
  }
  k++;
}
```
- Проходим пока не дойдём до конца
- Вложенный цикл проходи по `str2` и ищет, есть ли `str[k]` среди символов `str2`
- Если нашли совпадения то возр. `k`
- Нет совпадений? Неважно, идём дальше `k++`

#### 10 s21_strerror
`strerror` - преобразует код ошибки в человеческий формат

- Внутри `s21_strerror` есть массив который состоит из ошибок (для `MacOS 107 ошибок` и `Linux 135 ошибок` систем)
-  В каждом массиве строка с индексом `i` соответствует ошибке с кодом `i`

```c
#ifdef __APPLE__
    #define OS_ERRORS macos_errors
    #define OS_ERR_COUNT 107
#else
    #define OS_ERRORS linux_errors
    #define OS_ERR_COUNT 135
#endif
```
- Эти дерективы нужны для определения какую систему использовать

```c
static char unknown_error[30];
```
- Создаём статический буфер для неизвестной ошибки

```c
if (errnum >= 0 && errnum < OS_ERR_COUNT) {
    return OS_ERRORS[errnum];
}
```
- Если errnum в допустимом диапазоне (от `0` до `OS_ERR_COUNT`), возвращаем `OS_ERRORS[errnum]`, т.е. строку из массива с ошибками.

```c
s21_sprintf(unknown_error, "Unknown error %d", errnum);
```
- Форматирует строку `"Unknown error X"` и записывает её в `unknown_error`

Пример работы:
```c
int main() {
    printf("%s\n", s21_strerror(2));
    printf("%s\n", s21_strerror(200));
    return 0;
}
```
- 1. `No such file or directory`
- 2. `Unknown error 200`

#### 11 s21_strlen
`strlen` - возращяет длину строки

-----------
#### 12 s21_strpbrk
`strpbrk` - ищет в `str1` первый из символов, присутствующих в `str2`
```c
for (int i = 0; i < len_s1; i++) {
  for (int j = 0; j < len_s2; j++) {
    if (str2[j] == str1[i]) {
      return (char *)(str1 + i);
    }
  }
}
```
- Два вложенных цикла проходятся по `str1` и `str2`
- Идёт сравнение текущего в цикле символа их `str2` с `str1`
- Если символы совпадают вернуть указатель на этот символ
- В ином случае `s21_NULL`

#### 13 s21_strrchr
`strrchr` - в `str` ищет последнее вхождение символа `c`
```c
do {
  if (*str == c) {
    ptr = (char *)str;
  }
  str++;
} while (*(str - 1));
```
- Проходим `str` до `\0`
- Если `*str == c`, обновляем `ptr` но не выходим их цикла.
- Двигаем `c++`, но также проверяем `\0`. Т.к условие `*(str - 1)`
- `while (*(str - 1))` проверяет, что предыдущий символ `(str - 1)` не `'\0'`.
- Если `c` найден то `ptr` содержит указатель на последнее вхождение

#### 14 s21_strstr
`strstr` - ищет первое вхождение строки `needle` в `haystack`

```c
if (*needle == '\0') {
  _return = (char *)haystack;
}
```
- Если `needle` — пустая строка, по стандарту надо вернуть `haystack`.

```c
for (s21_size_t i = 0; i <= haystack_len - needle_len; i++) {
```
- Проверям подстроки длины `haystack_len` внутри `haystack`

```c
s21_size_t j = 0;
while (j < needle_len && haystack[i + j] == needle[j]) {
  j++;
}
```
- Пока символы совпадают идём дальше
- Если `j == needle_len`, значит нашли полное совпадение

- Обновляем `_return` на `haystack + i`.
-  `haystack + i` - даёт указатель на начало этого совпадения.

#### 15 s21_strtok
`strtok` - разбивает строки `str` на подстроки, разделённые их `delim`.
Например:
```
Hello, World! This is a test.
```
```
Token - ,! (пробел, запятая, воск.знак)
```
```
Hello
World
This
is
a
test
```

```c
while (*next_token && s21_strchr(delim, *next_token)) {
  next_token++;
}
```
- Пропуск разделителей в начале строки
- `s21_strchr(delim, *next_token)` проверяет, является ли текущий символ разделителем.

```c
while (*next_token && !s21_strchr(delim, *next_token)) {
  next_token++;
}
```

-----------
### Part 2.
Частичная реализация функции `sprintf`
*В самом коде указал что за что ответчает (`s21_stdio.h`) тут просто базовые объяснения*

#### Спецификаторы
| Спецификатор | Описание                        | Пример      |
|--------------|---------------------------------|-------------|
| %c           | char                            | %c  'A'     |
| %d           | int                             | %d  69      |
| %f           | float, double                   | %f  3.14    |
| %s           | char * (Срока)                  | %s "Hello"  |
| %u           | unsigned int                    | %u 1234567  |
| %%           | char * (Срока)                  | %% %        |
#### Флаги
| Флаги        | Описание                        | Пример                    |
|--------------|---------------------------------|---------------------------|
| -            | Выр. по левому краю             | |%-10d| -> |42    |       |
| +            | Всегда ставит знак перед числом | |%+d| -> +42              |
| (space)      | Доб. пробел перед положительным | ....                      | 

#### Ширина
| Ширина       | Описание                        | Пример                    |
|--------------|---------------------------------|---------------------------|
| %(число)(спец.) | Мин. ширина - (число)        | .....                     |

#### Точность
`Точность` или просто `.` Влияет на:
- Целые: Мин кол-во чисел
- Float/Double: Кол-во знаков после точки.
- Str: макс. кол-во символов для вывода

#### Длина
Спецификаторы длины `(h, l)` используются перед типом данных `(%d, %u, %x и т. д.)`, чтобы указывать, какого размера значение будет обрабатываться.

| **Спецификатор** | **Применяется к** | **Описание** |
|---------------|----------------|-------------|
| `h`  | `%d`, `%u`, `%x`, `%o` | **short int** (16 бит) |
| `l`  | `%d`, `%u`, `%x`, `%o`, `%f`, `%s`, `%c` | **long int** (32/64 бит) |

------

### Part 3.
Просто нужно допилить `sprintf` из `part 2`

#### Спецификаторы
| **Спецификатор** | **Описание** | **Пример** (`printf(...)`) | **Вывод** |
|---------------|-------------|-------------|----------|
| `%g`  | Оптимальный выбор между `%f` и `%e` (без лишних нулей) | `printf("%g", 0.0000123);` | `1.23e-05` |
| `%G`  | То же самое, но с заглавной `E` | `printf("%G", 1234567.89);` | `1.23457E+06` |
| `%e`  | Экспоненциальная нотация (маленькая `e`) | `printf("%e", 1234.567);` | `1.234567e+03` |
| `%E`  | Экспоненциальная нотация (большая `E`) | `printf("%E", 1234.567);` | `1.234567E+03` |
| `%x`  | Шестнадцатеричное число (маленькие буквы `a-f`) | `printf("%x", 255);` | `ff` |
| `%X`  | Шестнадцатеричное число (большие буквы `A-F`) | `printf("%X", 255);` | `FF` |
| `%o`  | Восьмеричное число | `printf("%o", 255);` | `377` |
| `%p`  | Адрес указателя | `printf("%p", (void*)&x);` | `0x7ffee4b7c710` |

#### Ширина
`*` - позволяет задавать ширину вывода через аргумент функции

#### Точность
`.*` - тоже самое что и в ширине но только для точности

#### Длина
`L` - `long double` для `%f` `%e` `%g`

### Part 4.
Не делали и не будем :)

------
### Part 5.
#### s21_insert
`insert` - вставляет `str` в `src` на позицию `start_index`

```c
  if (src != s21_NULL && start_index <= s21_strlen(src)) {
    s21_size_t src_len = s21_strlen(src);
    s21_size_t str_len = (str != s21_NULL) ? s21_strlen(str) : 0;
    s21_size_t new_len = src_len + str_len + 1;

    char *result = calloc(new_len, sizeof(char));
    if (result != s21_NULL) {
      s21_memcpy(result, src, start_index);

      if (str != s21_NULL) {
        s21_memcpy(result + start_index, str, str_len);
      }

      s21_memcpy(result + start_index + str_len, src + start_index,
                 src_len - start_index);

      result[new_len - 1] = '\0';

      _return = (void *)result;
    }
  }
```
- Проверяем `src` на `NULL`. Вставлять некуда если `src == NULL`
- Проверяем `start_index`. Он не должен быть больше длины `src`
- `str_len` - это `str`. 0, если `str == null`

#### s21_to_lower
`to_lower()` - просто переводит буквы в нижний регистр

#### s21_to_upper
`to_upper` - то же самое, но только в верхний 

#### s21_trim
`trim` - указанные символы в `trim_chars` удаляет из начала и конца строки `src`. Если `trim_chars == NULL` то по умолчанию удаляем - `\t\n ` 
